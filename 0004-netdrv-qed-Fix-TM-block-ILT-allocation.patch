From bb8838c7025ff54d00de1a34d87b424f89390218 Mon Sep 17 00:00:00 2001
From: Don Dutile <ddutile@redhat.com>
Date: Thu, 9 Nov 2017 06:47:58 -0500
Subject: [PATCH 1/3] [netdrv] qed: Fix TM block ILT allocation

Message-id: <20171109065423.8574-84-ddutile@redhat.com>
Patchwork-id: 197062
O-Subject: [PATCH RHEL-7.5 v2 083/468] qed: Fix TM block ILT allocation
Bugzilla: 1462433 1499362
RH-Acked-by: Jerry Snitselaar <jsnitsel@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Tony Camuso <tcamuso@redhat.com>

commit 44531ba45dbf3c23cc7ae0934ec9b33ef340ac56
Author: Michal Kalderon <Michal.Kalderon@cavium.com>
Date:   Mon Apr 3 12:21:10 2017 +0300

    qed: Fix TM block ILT allocation

    When configuring the HW timers block we should set the number of CIDs
    up until the last CID that require timers, instead of only those CIDs
    whose protocol needs timers support.

    Today, the protocols that require HW timers' support have their CIDs
    before any other protocol, but that would change in future [when we
    add iWARP support].

    Signed-off-by: Michal Kalderon <Michal.Kalderon@cavium.com>
    Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1462433

Signed-off-by: Donald Dutile <ddutile@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>
---
 drivers/net/ethernet/qlogic/qed/qed_cxt.c | 32 ++++++++++++++++++++++++-------
 1 file changed, 25 insertions(+), 7 deletions(-)

Index: src/drivers/net/ethernet/qlogic/qed/qed_cxt.c
===================================================================
--- src.orig/drivers/net/ethernet/qlogic/qed/qed_cxt.c	2017-12-04 17:11:08.076505842 +0100
+++ src/drivers/net/ethernet/qlogic/qed/qed_cxt.c	2017-12-04 17:13:52.518256604 +0100
@@ -303,16 +303,34 @@
 	u32 per_vf_tids;
 };
 
-static void qed_cxt_tm_iids(struct qed_cxt_mngr *p_mngr,
+static void qed_cxt_tm_iids(struct qed_hwfn *p_hwfn,
+			    struct qed_cxt_mngr *p_mngr,
 			    struct qed_tm_iids *iids)
 {
-	u32 i, j;
-
-	for (i = 0; i < MAX_CONN_TYPES; i++) {
+	bool tm_vf_required = false;
+	bool tm_required = false;
+	int i, j;
+
+	/* Timers is a special case -> we don't count how many cids require
+	 * timers but what's the max cid that will be used by the timer block.
+	 * therefore we traverse in reverse order, and once we hit a protocol
+	 * that requires the timers memory, we'll sum all the protocols up
+	 * to that one.
+	 */
+	for (i = MAX_CONN_TYPES - 1; i >= 0; i--) {
 		struct qed_conn_type_cfg *p_cfg = &p_mngr->conn_cfg[i];
 
-		if (tm_cid_proto(i)) {
+		if (tm_cid_proto(i) || tm_required) {
+			if (p_cfg->cid_count)
+				tm_required = true;
+
 			iids->pf_cids += p_cfg->cid_count;
+		}
+
+		if (tm_cid_proto(i) || tm_vf_required) {
+			if (p_cfg->cids_per_vf)
+				tm_vf_required = true;
+
 			iids->per_vf_cids += p_cfg->cids_per_vf;
 		}
 
@@ -744,7 +762,7 @@
 
 	/* TM PF */
 	p_cli = &p_mngr->clients[ILT_CLI_TM];
-	qed_cxt_tm_iids(p_mngr, &tm_iids);
+	qed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);
 	total = tm_iids.pf_cids + tm_iids.pf_tids_total;
 	if (total) {
 		p_blk = &p_cli->pf_blks[0];
@@ -1632,7 +1650,7 @@
 	u8 i;
 
 	memset(&tm_iids, 0, sizeof(tm_iids));
-	qed_cxt_tm_iids(p_mngr, &tm_iids);
+	qed_cxt_tm_iids(p_hwfn, p_mngr, &tm_iids);
 
 	/* @@@TBD No pre-scan for now */
 
